In react, HTML code is written in JavaScript file(JSX)
The JavaScript files and not explicitly mentioned in the index.html(main html) but it gets added when loading the page automatically because the html is transformed and then loaded
React project uses a build process before it can be installed or used anywhere.
Raw and unprocessed react code wont execute in the browser.
The code will not be optimised/minified in production.
Node JS and used behind the scenes to make sure your React code gets transformed.

for import and export keywords to work in a JavaScript project you have to be using the module keyword in the index.html file. 
<script src="assets/scripts/App.js" type="module"></script>

in javascript you cannot have two default statements 

in react, we must have one component/one javascript function per file. and this one component function is exported using the statement :
	export default ComponentName;
	
"let" can be reassigned but "const" cannot be reassigned in JS

Operators:
console.log(10 / 5);--2
console.log("hello" + " world");--hello world
console.log(10 === 1);--false
console.log(10 >= 12);--false

Arrow functions are used when functions dont need a name(anonymous function) : 

() => {

}
anonymous functions can also be declared as below:
export default function(){
console.log("Hello");
}
When working with Arrow Functions, you have a couple of "syntax shortcuts" available.

Most importantly, you should know about the following alternatives:

1) Omitting parameter list parentheses

If your arrow functions takes exactly one parameter, you may omit the wrapping parentheses.

Instead of

(userName) => { ... }
you could write

userName => { ... }
Please note: 

If your function takes no parameters, parentheses must not be omitted - () => { ... } is the only correct form in that case.

If your function takes more than one parameter, you also must not omit parentheses - 
userName, userAge => { ... } would be invalid ((userName, userAge) => { ... } is correct)!

2) Omitting function body curly braces

If your arrow function contains no other logic but a return statement, you may omit the curly braces and the return keyword.

Instead of

number => { 
  return number * 3;
}
you could write

number => number * 3;
The following code would be invalid:

number => return number * 3; // invalid because return keyword must also be omitted!
number => if (number === 2) { return 5 }; // invalid because if statements can't be returned
3) Special case: Just returning an object

If you go for the shorter alternative explained in 2) and you're trying to return a JavaScript object, you may end up with the following, 
invalid code:

number => { age: number }; // trying to return an object
This code would be invalid because JavaScript treats the curly braces as function body wrappers (not as code that creates a JS object).

To "tell" JavaScript that an object should be created (and returned) instead, the code would need to be adjusted like this:

number => ({ age: number }); // wrapping the object in extra parentheses
By wrapping the object and its curly braces with an extra pair of parentheses, JavaScript understands that the curly braces are not there to define a
 function body but instead to create an object. Hence that object then gets returned.

Objects can also have methods in javascript


Destructuring in Function Parameter Lists
The destructuring syntax explained in the previous lecture can also be used in function parameter lists.

For example, if a function accepts a parameter that will contain an object it can be destructured to "pull out" the object properties and make them available as locally scoped variables (i.e., variables only available inside the function body).

Here's an example:

function storeOrder(order) {
  localStorage.setItem('id', order.id);
  localStorage.setItem('currency', order.currency);
}
Instead of accessing the order properties via the "dot notation" inside the storeOrder function body, you could use destructuring like this:

function storeOrder({id, currency}) { // destructuring
  localStorage.setItem('id', id);
  localStorage.setItem('currency', currency);
}

The destructuring syntax is the same as taught in the previous lecture - just without creating a constant or variable manually.

Instead, id and currency are "pulled out" of the incoming object (i.e., the object passed as an argument to storeOrder).

It's very important to understand, that storeOrder still only takes one parameter in this example! It does not accept two parameters. Instead, it's one single parameter - an object which then just is destructured internally.

The function would still be called like this:

storeOrder({id: 5, currency: 'USD', amount: 15.99}); // one argument / value!



